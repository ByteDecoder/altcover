using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

[assembly: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly",
  MessageId = "Api", Justification = "It's the API for the system")]

namespace AltCover
{
  /// <summary>
  ///  This class is the C#-friendly invocation API for the instrumentation and coverage collection core of AltCover
  /// </summary>
  [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly",
                    Justification = "It's the API for the system")]
  public static class CSApi
  {
    /// <summary>
    ///  This type defines the Collect (runner) behaviour.
    /// </summary>
    [SuppressMessage(
        "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
        Justification = "Design decision.")]
    [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
    public interface ICollectParameters
    {
      /// <summary>
      /// <para type="description">The folder containing the instrumented code to monitor (including the `AltCover.Recorder.g.dll` generated by previous a use of the .net core `AltCover`).</para>
      /// </summary>
      string RecorderDirectory { get; }

      /// <summary>
      /// <para type="description">The working directory for the application launch</para>
      /// </summary>
      string WorkingDirectory { get; }

      /// <summary>
      /// <para type="description">The executable to run e.g. `dotnet`</para>
      /// </summary>
      string Executable { get; }

      /// <summary>
      /// <para type="description">File path for lcov format version of the collected data</para>
      /// </summary>

      [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly",
        Justification = "Lcov is a name")]
      string LcovReport { get; }

      /// <summary>
      /// <para type="description">One or more of minimum acceptable statement (S), branch (B) or method (M) coverage percentage (integer, 1 to 100) or maximum acceptable CRAP score (C followed by integer, 1 to 255) e.g. M80C40B50. If the value starts with a number, a leading S is assumed. If any threshold is specified more than once, the last instance is assumed -- so 25S50 counts as S50. Zero/absent values are ignored. If a coverage result is below threshold, or the CRAP score is above threshold, the return code of the process is the largest abs(threshold - actual) rounded up to the nearest integer.</para>
      /// </summary>

      string Threshold { get; }
      /// <summary>
      /// <para type="description">File path for Cobertura format version of the collected data</para>
      /// </summary>

      [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly",
        Justification = "Cobertura is a name")]
      string Cobertura { get; }

      /// <summary>
      /// <para type="description">Write the recorded coverage to this file rather than overwriting the original report file.</para>
      /// </summary>

      string OutputFile { get; }

      /// <summary>
      /// <para type="description">Gets whether to report any non-zero return code from a launched process.</para>
      /// </summary>
      bool ExposeReturnCode { get; }

      /// <summary>
      /// <para type="description">Selects summary format (OpenCover style, or a TeamCity style, or both)</para>
      /// </summary>
      string SummaryFormat { get; }

      /// <summary>
      /// <para type="description">Arguments for a launched process</para>
      /// </summary>
      IEnumerable<string> CommandLine { get; }

      /// <summary>
      /// Returns the F#-defined equivalent type
      /// </summary>
      /// <returns>An immutable representation of the same structure</returns>
      FSApi.CollectParameters ToParameters();

      /// <summary>
      /// Check whether the parameters are sensible
      /// </summary>
      /// <param name="afterPreparation">Whether the prepare phase has been run and a `AltCover.Recorder.g.dll` should exist.</param>
      /// <returns>Any errors that would be reported to the command line</returns>
      IEnumerable<string> Validate(bool afterPreparation);

      /// <summary>
      /// Performs validation (implies `Validate`) suitable for a PowerShell `-WhatIf` query; the return type has form
      /// <code>
      ///  public sealed class ValidatedCommandLine
      ///  {
      ///    public IEnumerable<string> Command { get; } // Command line elements
      ///    public IEnumerable<string> Errors { get; } // Validation errors
      ///  }
      /// </code>
      /// </summary>
      /// <param name="afterPreparation">Whether the prepare phase has been run and a `AltCover.Recorder.g.dll` should exist.</param>
      /// <returns>The state of the command line</returns>
      FSApi.ValidatedCommandLine WhatIf(bool afterPreparation);
    }

    /// <summary>
    ///  This type defines the Prepare (instrumentation) behaviour.
    /// </summary>
    [SuppressMessage(
        "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
        Justification = "Design decision.")]
    [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
    public interface IPrepareParameters
    {
      /// <summary>
      /// <para type="description">Folder or folders containing assemblies to instrument (default: current directory)</para>
      /// </summary>
      IEnumerable<string> InputDirectories { get; }

      /// <summary>
      /// <para type="description">Folder or folders to receive the instrumented assemblies and their companions (default: sub-folder `__Instrumented` of the current directory; or `__Saved` if `-Inplace` is set).</para>
      /// </summary>
      IEnumerable<string> OutputDirectories { get; }

      /// <summary>
      /// <para type="description">Additional folder or folders to search for matching symbols for the assemblies in the input directory</para>
      /// </summary>
      IEnumerable<string> SymbolDirectories { get; }

      /// <summary>
      /// <para type="description">Assembly paths to resolve missing references.</para>
      /// </summary>
      IEnumerable<string> Dependencies { get; }

      /// <summary>
      /// <para type="description">Strong name key or keys that were used to sign the inputs</para>
      /// </summary>
      IEnumerable<string> Keys { get; }

      /// <summary>
      /// <para type="description">The default strong naming key to apply to instrumented assemblies</para>
      /// </summary>
      string StrongNameKey { get; }

      /// <summary>
      /// <para type="description">The output report template file (default: coverage.xml in the current directory)</para>
      /// </summary>
      string XmlReport { get; }

      /// <summary>
      /// <para type="description">Source file names to exclude from instrumentation</para>
      /// </summary>
      IEnumerable<string> FileFilter { get; }

      /// <summary>
      /// <para type="description">Assembly names to exclude from instrumentation (linked by instrumented assemblies)</para>
      /// </summary>
      IEnumerable<string> AssemblyFilter { get; }

      /// <summary>
      /// <para type="description">Assembly names to exclude from instrumentation (linked to instrumented assemblies)</para>
      /// </summary>
      IEnumerable<string> AssemblyExcludeFilter { get; }

      /// <summary>
      /// <para type="description">Type names to exclude from instrumentation</para>
      /// </summary>
      IEnumerable<string> TypeFilter { get; }

      /// <summary>
      /// <para type="description">Method names to exclude from instrumentation</para>
      /// </summary>
      IEnumerable<string> MethodFilter { get; }

      /// <summary>
      /// <para type="description">Attribute names to exclude from instrumentation</para>
      /// </summary>
      IEnumerable<string> AttributeFilter { get; }

      /// <summary>
      /// <para type="description">Source file paths to exclude from instrumentation</para>
      /// </summary>
      IEnumerable<string> PathFilter { get; }

      /// <summary>
      /// <para type="description">Tracking either times of visits in ticks or designated method calls leading to the visits.</para>
      /// <para type="description">A single digit 0-7 gives the number of decimal places of seconds to report; everything else is at the mercy of the system clock information available through DateTime.UtcNow</para>
      /// <para type="description">A string in brackets "[]" is interpreted as an attribute type name (the trailing "Attribute" is optional), so [Test] or [TestAttribute] will match; if the name contains one or more ".", then it will be matched against the full name of the attribute type.</para>
      /// <para type="description">Other strings are interpreted as method names (fully qualified if the string contains any "." characters).</para>
      /// <para type="description">Incompatible with `SingleVisit` being true</para>
      /// </summary>
      IEnumerable<string> CallContext { get; }

      /// <summary>
      /// <para type="description">Generate the report in the specified format (NCover or the default OpenCover)</para>
      /// </summary>
      string ReportFormat { get; }

      /// <summary>
      /// <para type="description">Indicate whether to instrument the inputDirectory, rather than the outputDirectory (e.g. for `dotnet test`)</para>
      /// </summary>
      bool InPlace { get; }

      /// <summary>
      /// <para type="description">Indicate whether to write raw coverage data to file for later processing</para>
      /// </summary>
      bool Save { get; }

      /// <summary>
      /// <para type="description">Indicate whether to emit the XML report inside a zip archive.</para>
      /// </summary>
      bool ZipFile { get; }

      /// <summary>
      /// <para type="description">Indicate whether to record only whether a method has been visited or not.  Overrides the `LineCover` and `BranchCover` options.</para>
      /// </summary>
      bool MethodPoint { get; }

      /// <summary>
      /// <para type="description">Indicate whether to record only the first hit at any location.  Incompatible with `-CallContext`.</para>
      /// </summary>
      bool SingleVisit { get; }

      /// <summary>
      /// <para type="description">Indicate whether to omit branch coverage.  Implies, and is compatible with, the -ReportFormat "opencover" option. Incompatible with `-BranchCover`.</para>
      /// </summary>
      bool LineCover { get; }

      /// <summary>
      /// <para type="description">Indicate whether to omit ine coverage.  Implies, and is compatible with, the -ReportFormat "opencover" option. Incompatible with `-LineCover`.</para>
      /// </summary>
      bool BranchCover { get; }

      /// <summary>
      /// <para type="description">Gets whether to report any non-zero return code from a launched process.</para>
      /// </summary>
      bool ExposeReturnCode { get; }

      /// <summary>
      /// <para type="description">Indicate whether to display sourcelink URLs rather than file paths if present.</para>
      /// </summary>
      bool SourceLink { get; }

      /// <summary>
      /// <para type="description">Indicate whether to defer writing runner-mode coverage data until process exit.</para>
      /// </summary>
      bool Defer { get; }

      /// <summary>
      /// <para type="description">Indicate whether to exclude for instrumentation code for which the source file is not present.</para>
      /// </summary>
      bool LocalSource { get; }

      /// <summary>
      /// <para type="description">Indicate whether to hide complex internal IL branching implementation details in switch/match constructs, and just show what the source level logic implies.</para>
      /// </summary>
      bool VisibleBranches { get; }

      /// <summary>
      /// <para type="description">Indicate whether to instrument and show code that is by default skipped as trivial.</para>
      /// </summary>
      string ShowStatic { get; }

      /// <summary>
      /// <para type="description">Indicate whether to mark generated code with a visit count of -2 (Automatic) for the Visualizer if unvisited</para>
      /// </summary>
      bool ShowGenerated { get; }

      /// <summary>
      /// <para type="description">Command and arguments for a launched process</para>
      /// </summary>
      IEnumerable<string> CommandLine { get; }

      /// <summary>
      /// Returns the F#-defined equivalent type
      /// </summary>
      /// <returns>An immutable representation of the same structure</returns>
      FSApi.PrepareParameters ToParameters();

      /// <summary>
      /// Check whether the parameters are sensible
      /// </summary>
      /// <returns>Any errors that would be reported to the command line</returns>
      IEnumerable<string> Validate();

      /// <summary>
      /// Performs validation (implies `Validate`) suitable for a PowerShell `-WhatIf` query; the return type has form
      /// <code>
      ///  public sealed class ValidatedCommandLine
      ///  {
      ///    public IEnumerable<string> Command { get; } // Command line elements
      ///    public IEnumerable<string> Errors { get; } // Validation errors
      ///  }
      /// </code>
      /// </summary>
      /// <returns>The state of the command line</returns>
      FSApi.ValidatedCommandLine WhatIf();
    }

    /// <summary>
    ///
    /// </summary>
    [SuppressMessage(
        "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
        Justification = "Design decision.")]
    [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
    public interface ILogging
    {
      /// <summary>
      ///
      /// </summary>
      Action<String> Info { get; }

      /// <summary>
      ///
      /// </summary>
      Action<String> Warn { get; }

      /// <summary>
      ///
      /// </summary>
      Action<String> StandardError { get; }

      /// <summary>
      ///
      /// </summary>
      Action<String> Echo { get; }

      /// <summary>
      ///
      /// </summary>
      /// <returns></returns>
      FSApi.Logging ToParameters();
    }

    /// <summary>
    ///
    /// </summary>
    [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly",
      Justification = "CLI is a standard TLA")]
    [SuppressMessage(
          "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
          Justification = "Design decision.")]
    [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
    public interface ICLIOptions
    {
      /// <summary>
      ///
      /// </summary>
      bool Force { get; }

      /// <summary>
      ///
      /// </summary>
      bool FailFast { get; }

      /// <summary>
      ///
      /// </summary>
      string ShowSummary { get; }
    }

    /// <summary>
    ///
    /// </summary>
    [SuppressMessage(
        "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
        Justification = "Design decision.")]
    [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
    public static class Primitive
    {
      /// <summary>
      ///
      /// </summary>
      [SuppressMessage(
          "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
          Justification = "Design decision.")]
      [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
      [SuppressMessage(
      "Gendarme.Rules.Maintainability", "AvoidLackOfCohesionOfMethodsRule",
      Justification = "What's there not to get?")]
      public class CollectParameters : ICollectParameters
      {
        /// <summary>
        ///
        /// </summary>
        private IEnumerable<string> commandLine;

        /// <summary>
        ///
        /// </summary>
        public string RecorderDirectory { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string WorkingDirectory { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string Executable { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string LcovReport { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string Threshold { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string Cobertura { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string OutputFile { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string SummaryFormat { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> CommandLine
        {
          get
          {
            return commandLine.ToArray();
          }
          set
          {
            commandLine = (value ?? Enumerable.Empty<string>()).ToArray();
          }
        }

        /// <summary>
        ///
        /// </summary>
        public bool ExposeReturnCode { get; set; }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public FSApi.CollectParameters ToParameters()
        {
          var primitive = new AltCover.Primitive.CollectParameters(
              RecorderDirectory,
              WorkingDirectory,
              Executable,
              LcovReport,
              Threshold,
              Cobertura,
              OutputFile,
              CommandLine,
              ExposeReturnCode,
              SummaryFormat
                                                              );
          return FSApi.CollectParameters.NewPrimitive(primitive);
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public static CollectParameters Create()
        {
          return new CollectParameters
          {
            RecorderDirectory = string.Empty,
            WorkingDirectory = string.Empty,
            Executable = string.Empty,
            LcovReport = string.Empty,
            Threshold = string.Empty,
            Cobertura = string.Empty,
            OutputFile = string.Empty,
            CommandLine = Enumerable.Empty<string>(),
            ExposeReturnCode = true,
            SummaryFormat = string.Empty
          };
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="afterPreparation"></param>
        /// <returns></returns>
        public IEnumerable<string> Validate(bool afterPreparation)
        {
          return ToParameters().Validate(afterPreparation);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="afterPreparation"></param>
        /// <returns></returns>
        public FSApi.ValidatedCommandLine WhatIf(bool afterPreparation)
        {
          return ToParameters().WhatIf(afterPreparation);
        }
      }

      /// <summary>
      ///
      /// </summary>
      [SuppressMessage(
          "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
          Justification = "Design decision.")]
      [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
      public class PrepareParameters : IPrepareParameters
      {
        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> InputDirectories { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> OutputDirectories { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> SymbolDirectories { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> Dependencies { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> Keys { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string StrongNameKey { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string XmlReport { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> FileFilter { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> AssemblyFilter { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> AssemblyExcludeFilter { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> TypeFilter { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> MethodFilter { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> AttributeFilter { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> PathFilter { get; set; }

        /// <summary>
        ///
        /// </summary>
        public IEnumerable<string> CallContext { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string ReportFormat { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool InPlace { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool Save { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool ZipFile { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool MethodPoint { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool SingleVisit { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool LineCover { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool BranchCover { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool ExposeReturnCode { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool SourceLink { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool Defer { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool LocalSource { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool VisibleBranches { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string ShowStatic { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool ShowGenerated { get; set; }

        /// <summary>
        ///
        /// </summary>

        public IEnumerable<string> CommandLine { get; set; }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public FSApi.PrepareParameters ToParameters()
        {
          var primitive = new AltCover.Primitive.PrepareParameters(
                          InputDirectories,
                          OutputDirectories,
                          SymbolDirectories,
                          Dependencies,
                          Keys,
                          StrongNameKey,
                          XmlReport,
                          FileFilter,
                          AssemblyFilter,
                          AssemblyExcludeFilter,
                          TypeFilter,
                          MethodFilter,
                          AttributeFilter,
                          PathFilter,
                          CallContext,

                          ReportFormat,
                          InPlace,
                          Save,
                          ZipFile,
                          MethodPoint,
                          SingleVisit,
                          LineCover,
                          BranchCover,
                          CommandLine,
                          ExposeReturnCode,
                          SourceLink,
                          Defer,
                          LocalSource,
                          VisibleBranches,
                          ShowStatic,
                          ShowGenerated
                                                              );
          return FSApi.PrepareParameters.NewPrimitive(primitive);
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public static PrepareParameters Create()
        {
          return new PrepareParameters
          {
            InputDirectories = new string[0],
            OutputDirectories = new string[0],
            SymbolDirectories = new string[0],
            Dependencies = new string[0],
            Keys = new string[0],
            StrongNameKey = string.Empty,
            XmlReport = string.Empty,
            FileFilter = new string[0],
            AssemblyFilter = new string[0],
            AssemblyExcludeFilter = new string[0],
            TypeFilter = new string[0],
            MethodFilter = new string[0],
            AttributeFilter = new string[0],
            PathFilter = new string[0],
            CallContext = new string[0],

            ReportFormat = "OpenCover",
            InPlace = true,
            Save = true,
            SingleVisit = false,
            LineCover = false,
            BranchCover = false,
            CommandLine = { },

            ExposeReturnCode = true,
            SourceLink = false,
            Defer = false
          };
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public IEnumerable<string> Validate()
        {
          return ToParameters().Validate();
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public FSApi.ValidatedCommandLine WhatIf()
        {
          return ToParameters().WhatIf();
        }
      }

      /// <summary>
      ///
      /// </summary>
      [SuppressMessage(
          "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
          Justification = "Design decision.")]
      [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
      public class LoggingParameters : ILogging
      {
        /// <summary>
        ///
        /// </summary>
        public Action<String> Info { get; set; }

        /// <summary>
        ///
        /// </summary>
        public Action<String> Warn { get; set; }

        /// <summary>
        ///
        /// </summary>
        public Action<String> StandardError { get; set; }

        /// <summary>
        ///
        /// </summary>
        public Action<String> Echo { get; set; }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public FSApi.Logging ToParameters()
        {
          var primitive = new AltCover.Primitive.Logging(
              FSApi.Logging.ActionAdapter(Info),
              FSApi.Logging.ActionAdapter(Warn),
              FSApi.Logging.ActionAdapter(StandardError),
              FSApi.Logging.ActionAdapter(Echo));
          return FSApi.Logging.NewPrimitive(primitive);
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public static LoggingParameters Create()
        {
          return new LoggingParameters
          {
            Info = x => { },
            Warn = x => { },
            StandardError = x => { },
            Echo = x => { }
          };
        }
      }

      /// <summary>
      ///
      /// </summary>
      [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly",
        Justification = "CLI is a standard TLA")]
      [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
      [SuppressMessage(
          "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
          Justification = "Design decision.")]
      [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
      public class CLIOptions : ICLIOptions
      {
        /// <summary>
        ///
        /// </summary>
        public bool Force { get; set; }

        /// <summary>
        ///
        /// </summary>
        public bool FailFast { get; set; }

        /// <summary>
        ///
        /// </summary>
        public string ShowSummary { get; set; }
      }
    }

    /// <summary>
    ///
    /// </summary>
    /// <param name="prepareArgs"></param>
    /// <param name="log"></param>
    /// <returns></returns>
    public static int Prepare(IPrepareParameters prepareArgs, ILogging log)
    {
      if (prepareArgs == null) throw new ArgumentNullException(nameof(prepareArgs));
      if (log == null) throw new ArgumentNullException(nameof(log));
      return Api.Prepare(prepareArgs.ToParameters(), log.ToParameters());
    }

    /// <summary>
    ///
    /// </summary>
    /// <param name="collectArgs"></param>
    /// <param name="log"></param>
    /// <returns></returns>
    public static int Collect(ICollectParameters collectArgs, ILogging log)
    {
      if (collectArgs == null) throw new ArgumentNullException(nameof(collectArgs));
      if (log == null) throw new ArgumentNullException(nameof(log));
      return Api.Collect(collectArgs.ToParameters(), log.ToParameters());
    }

    /// <summary>
    ///
    /// </summary>
    /// <returns></returns>
    public static string ImportModule()
    {
      return Api.ImportModule();
    }

    /// <summary>
    ///
    /// </summary>
    /// <returns></returns>
    public static Version Version()
    {
      return Api.Version();
    }

    /// <summary>
    ///
    /// </summary>
    /// <param name="args"></param>
    /// <returns></returns>
    private static DotNet.CLIOptions ToCLIOptions(ICLIOptions args)
    {
      var force = DotNet.CLIOptions.NewForce(args.Force);
      var failfast = DotNet.CLIOptions.NewFailFast(args.FailFast);
      var showsummary = DotNet.CLIOptions.NewShowSummary(args.ShowSummary);
      return DotNet.CLIOptions.NewMany(new[] { force, failfast, showsummary });
    }

    /// <summary>
    ///
    /// </summary>
    /// <param name="prepareArgs"></param>
    /// <param name="collectArgs"></param>
    /// <param name="control"></param>
    /// <returns></returns>
    public static string ToTestArguments(IPrepareParameters prepareArgs,
                                         ICollectParameters collectArgs,
                                         ICLIOptions control)
    {
      if (prepareArgs == null) throw new ArgumentNullException(nameof(prepareArgs));
      if (collectArgs == null) throw new ArgumentNullException(nameof(collectArgs));
      return DotNet.ToTestArguments(prepareArgs.ToParameters(),
                                    collectArgs.ToParameters(),
                                    ToCLIOptions(control));
    }

    /// <summary>
    ///
    /// </summary>
    /// <param name="prepareArgs"></param>
    /// <param name="collectArgs"></param>
    /// <param name="control"></param>
    /// <returns></returns>
    public static IEnumerable<string> ToTestArgumentList(IPrepareParameters prepareArgs,
                                              ICollectParameters collectArgs,
                                              ICLIOptions control)
    {
      if (prepareArgs == null) throw new ArgumentNullException(nameof(prepareArgs));
      if (collectArgs == null) throw new ArgumentNullException(nameof(collectArgs));
      return DotNet.ToTestArgumentList(prepareArgs.ToParameters(),
                                       collectArgs.ToParameters(),
                                       ToCLIOptions(control)).
      ToArray();
    }
  }
}