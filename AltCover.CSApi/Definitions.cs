using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using AltCover;
using AltCover.FSApi;

[assembly: SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly",
  MessageId = "Api", Justification = "It's the API for the system")]

namespace AltCover
{
  /// <summary>
  ///  This class is the C#-friendly invocation API for the instrumentation and coverage collection core of AltCover
  /// </summary>
  [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly",
                    Justification = "It's the API for the system")]
  public static class CSApi
  {
    /// <summary>
    ///  This type defines the Collect (runner) behaviour.  The properties map on to the command line arguments for `altcover runner`
    /// </summary>
    [SuppressMessage(
        "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
        Justification = "Design decision.")]
    [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
    public interface ICollectOptions
    {
      /// <summary>
      /// <para type="description">The folder containing the instrumented code to monitor (including the `AltCover.Recorder.g.dll` generated by previous a use of the .net core `AltCover`).</para>
      /// </summary>
      string RecorderDirectory { get; }

      /// <summary>
      /// <para type="description">The working directory for the application launch</para>
      /// </summary>
      string WorkingDirectory { get; }

      /// <summary>
      /// <para type="description">The executable to run e.g. `dotnet`</para>
      /// </summary>
      string Executable { get; }

      /// <summary>
      /// <para type="description">File path for lcov format version of the collected data</para>
      /// </summary>

      [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly",
        Justification = "Lcov is a name")]
      string LcovReport { get; }

      /// <summary>
      /// <para type="description">One or more of minimum acceptable statement (S), branch (B) or method (M) coverage percentage (integer, 1 to 100) or maximum acceptable CRAP score (C followed by integer, 1 to 255) e.g. M80C40B50. If the value starts with a number, a leading S is assumed. If any threshold is specified more than once, the last instance is assumed -- so 25S50 counts as S50. Zero/absent values are ignored. If a coverage result is below threshold, or the CRAP score is above threshold, the return code of the process is the largest abs(threshold - actual) rounded up to the nearest integer.</para>
      /// </summary>

      string Threshold { get; }
      /// <summary>
      /// <para type="description">File path for Cobertura format version of the collected data</para>
      /// </summary>

      [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly",
        Justification = "Cobertura is a name")]
      string Cobertura { get; }

      /// <summary>
      /// <para type="description">Write the recorded coverage to this file rather than overwriting the original report file.</para>
      /// </summary>

      string OutputFile { get; }

      /// <summary>
      /// <para type="description">Gets whether to report any non-zero return code from a launched process.</para>
      /// </summary>
      bool ExposeReturnCode { get; }

      /// <summary>
      /// <para type="description">Selects summary format (OpenCover style, or a TeamCity style, or both)</para>
      /// </summary>
      string SummaryFormat { get; }

      /// <summary>
      /// <para type="description">Arguments for a launched process</para>
      /// </summary>
      IEnumerable<string> CommandLine { get; }

      /// <summary>
      /// Returns the F#-defined equivalent type
      /// </summary>
      /// <returns>An immutable representation of the same structure</returns>
      OptionApi.CollectOptions ToOptions();

      /// <summary>
      /// Check whether the parameters are sensible
      /// </summary>
      /// <param name="afterPreparation">Whether the prepare phase has been run and a `AltCover.Recorder.g.dll` should exist.</param>
      /// <returns>Any errors that would be reported to the command line</returns>
      IEnumerable<string> Validate(bool afterPreparation);

      /// <summary>
      /// Performs validation (implies `Validate`) suitable for a PowerShell `-WhatIf` query; the return type has form
      /// <code>
      ///  public sealed class ValidatedCommandLine
      ///  {
      ///    public IEnumerable&lt;string&gt; Command { get; } // Command line elements
      ///    public IEnumerable&lt;string&gt; Errors { get; } // Validation errors
      ///    public override string ToString(); // nicely formatted
      ///  }
      /// </code>
      /// </summary>
      /// <param name="afterPreparation">Whether the prepare phase has been run and a `AltCover.Recorder.g.dll` should exist.</param>
      /// <returns>The state of the command line</returns>
      OptionApi.ValidatedCommandLine WhatIf(bool afterPreparation);
    }

    /// <summary>
    ///  This type defines the Prepare (instrumentation) behaviour.    The properties map on to the command line arguments for `altcover`
    /// </summary>
    [SuppressMessage(
        "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
        Justification = "Design decision.")]
    [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
    public interface IPrepareOptions
    {
      /// <summary>
      /// <para type="description">Folder or folders containing assemblies to instrument (default: current directory)</para>
      /// </summary>
      IEnumerable<string> InputDirectories { get; }

      /// <summary>
      /// <para type="description">Folder or folders to receive the instrumented assemblies and their companions (default: sub-folder `__Instrumented` of the current directory; or `__Saved` if `-Inplace` is set).</para>
      /// </summary>
      IEnumerable<string> OutputDirectories { get; }

      /// <summary>
      /// <para type="description">Additional folder or folders to search for matching symbols for the assemblies in the input directory</para>
      /// </summary>
      IEnumerable<string> SymbolDirectories { get; }

      /// <summary>
      /// <para type="description">Assembly paths to resolve missing references.</para>
      /// </summary>
      IEnumerable<string> Dependencies { get; }

      /// <summary>
      /// <para type="description">Strong name key or keys that were used to sign the inputs</para>
      /// </summary>
      IEnumerable<string> Keys { get; }

      /// <summary>
      /// <para type="description">The default strong naming key to apply to instrumented assemblies</para>
      /// </summary>
      string StrongNameKey { get; }

      /// <summary>
      /// <para type="description">The output report template file (default: coverage.xml in the current directory)</para>
      /// </summary>
      string XmlReport { get; }

      /// <summary>
      /// <para type="description">Source file names to exclude from instrumentation</para>
      /// </summary>
      IEnumerable<string> FileFilter { get; }

      /// <summary>
      /// <para type="description">Assembly names to exclude from instrumentation (linked by instrumented assemblies)</para>
      /// </summary>
      IEnumerable<string> AssemblyFilter { get; }

      /// <summary>
      /// <para type="description">Assembly names to exclude from instrumentation (linked to instrumented assemblies)</para>
      /// </summary>
      IEnumerable<string> AssemblyExcludeFilter { get; }

      /// <summary>
      /// <para type="description">Type names to exclude from instrumentation</para>
      /// </summary>
      IEnumerable<string> TypeFilter { get; }

      /// <summary>
      /// <para type="description">Method names to exclude from instrumentation</para>
      /// </summary>
      IEnumerable<string> MethodFilter { get; }

      /// <summary>
      /// <para type="description">Attribute names to exclude from instrumentation</para>
      /// </summary>
      IEnumerable<string> AttributeFilter { get; }

      /// <summary>
      /// <para type="description">Source file paths to exclude from instrumentation</para>
      /// </summary>
      IEnumerable<string> PathFilter { get; }

      /// <summary>
      /// <para type="description">Tracking either times of visits in ticks or designated method calls leading to the visits.</para>
      /// <para type="description">A single digit 0-7 gives the number of decimal places of seconds to report; everything else is at the mercy of the system clock information available through DateTime.UtcNow</para>
      /// <para type="description">A string in brackets "[]" is interpreted as an attribute type name (the trailing "Attribute" is optional), so [Test] or [TestAttribute] will match; if the name contains one or more ".", then it will be matched against the full name of the attribute type.</para>
      /// <para type="description">Other strings are interpreted as method names (fully qualified if the string contains any "." characters).</para>
      /// <para type="description">Incompatible with `SingleVisit` being true</para>
      /// </summary>
      IEnumerable<string> CallContext { get; }

      /// <summary>
      /// <para type="description">Generate the report in the specified format (NCover or the default OpenCover)</para>
      /// </summary>
      string ReportFormat { get; }

      /// <summary>
      /// <para type="description">Indicate whether to instrument the inputDirectory, rather than the outputDirectory (e.g. for `dotnet test`)</para>
      /// </summary>
      bool InPlace { get; }

      /// <summary>
      /// <para type="description">Indicate whether to write raw coverage data to file for later processing</para>
      /// </summary>
      bool Save { get; }

      /// <summary>
      /// <para type="description">Indicate whether to emit the XML report inside a zip archive.</para>
      /// </summary>
      bool ZipFile { get; }

      /// <summary>
      /// <para type="description">Indicate whether to record only whether a method has been visited or not.  Overrides the `LineCover` and `BranchCover` options.</para>
      /// </summary>
      bool MethodPoint { get; }

      /// <summary>
      /// <para type="description">Indicate whether to record only the first hit at any location.  Incompatible with `-CallContext`.</para>
      /// </summary>
      bool SingleVisit { get; }

      /// <summary>
      /// <para type="description">Indicate whether to omit branch coverage.  Implies, and is compatible with, the -ReportFormat "opencover" option. Incompatible with `-BranchCover`.</para>
      /// </summary>
      bool LineCover { get; }

      /// <summary>
      /// <para type="description">Indicate whether to omit ine coverage.  Implies, and is compatible with, the -ReportFormat "opencover" option. Incompatible with `-LineCover`.</para>
      /// </summary>
      bool BranchCover { get; }

      /// <summary>
      /// <para type="description">Gets whether to report any non-zero return code from a launched process.</para>
      /// </summary>
      bool ExposeReturnCode { get; }

      /// <summary>
      /// <para type="description">Indicate whether to display sourcelink URLs rather than file paths if present.</para>
      /// </summary>
      bool SourceLink { get; }

      /// <summary>
      /// <para type="description">Indicate whether to defer writing runner-mode coverage data until process exit.</para>
      /// </summary>
      bool Defer { get; }

      /// <summary>
      /// <para type="description">Indicate whether to exclude for instrumentation code for which the source file is not present.</para>
      /// </summary>
      bool LocalSource { get; }

      /// <summary>
      /// <para type="description">Indicate whether to hide complex internal IL branching implementation details in switch/match constructs, and just show what the source level logic implies.</para>
      /// </summary>
      bool VisibleBranches { get; }

      /// <summary>
      /// <para type="description">Indicate whether to instrument and show code that is by default skipped as trivial.</para>
      /// </summary>
      string ShowStatic { get; }

      /// <summary>
      /// <para type="description">Indicate whether to mark generated code with a visit count of -2 (Automatic) for the Visualizer if unvisited</para>
      /// </summary>
      bool ShowGenerated { get; }

      /// <summary>
      /// <para type="description">Command and arguments for a launched process</para>
      /// </summary>
      IEnumerable<string> CommandLine { get; }

      /// <summary>
      /// Returns the F#-defined equivalent type
      /// </summary>
      /// <returns>An immutable representation of the same structure</returns>
      OptionApi.PrepareOptions ToOptions();

      /// <summary>
      /// Check whether the parameters are sensible
      /// </summary>
      /// <returns>Any errors that would be reported to the command line</returns>
      IEnumerable<string> Validate();

      /// <summary>
      /// Performs validation (implies `Validate`) suitable for a PowerShell `-WhatIf` query; the return type has form
      /// <code>
      ///  public sealed class ValidatedCommandLine
      ///  {
      ///    public IEnumerable&lt;string&gt; Command { get; } // Command line elements
      ///    public IEnumerable&lt;string&gt; Errors { get; } // Validation errors
      ///    public override string ToString(); // nicely formatted
      ///  }
      /// </code>
      /// </summary>
      /// <returns>The state of the command line</returns>
      OptionApi.ValidatedCommandLine WhatIf();
    }

    /// <summary>
    /// Defines how to log output from the `altcover` operation
    /// </summary>
    [SuppressMessage(
        "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
        Justification = "Design decision.")]
    [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
    public interface ILoggingOptions
    {
      /// <summary>
      /// Sink for informational messages
      /// </summary>
      Action<String> Info { get; }

      /// <summary>
      /// Sink for warning messages
      /// </summary>
      Action<String> Warn { get; }

      /// <summary>
      ///  Sink for error messages
      /// </summary>
      Action<String> StandardError { get; }

      /// <summary>
      /// Sink for the synthetic command line in case of inconsistent inputs.
      /// </summary>
      Action<String> Echo { get; }

      /// <summary>
      /// Returns the F#-defined equivalent type
      /// </summary>
      /// <returns>An immutable representation of the same structure</returns>
      OptionApi.LoggingOptions ToOptions();
    }

    /// <summary>
    ///  Represents  other `altcover`-related command line arguments for the `dotnet test` operation
    /// </summary>
    [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly",
      Justification = "CLI is a standard TLA")]
    [SuppressMessage(
          "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
          Justification = "Design decision.")]
    [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
    public interface ICLIOptions
    {
      /// <summary>
      /// Indicates whether a left-over `__Saved` directory from a previous run should be forcibly deleted
      /// </summary>
      bool Force { get; }

      /// <summary>
      /// Indicates whether to exit if the tests fail, without processing coverage data
      /// </summary>
      bool FailFast { get; }

      /// <summary>
      /// Indicates the colour to use to display the coverage summary to stdout; a non-colour will use system default, empty will echo nothing
      /// </summary>
      string ShowSummary { get; }
    }

    /// <summary>
    /// `"Stringly-typed" implemenations of the above
    /// </summary>
    [SuppressMessage(
        "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
        Justification = "Design decision.")]
    [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
    public static class Primitive
    {
      /// <summary>
      ///  This type defines the Collect (runner) behaviour.  The properties map on to the command line arguments for `altcover runner`
      /// </summary>
      [SuppressMessage(
          "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
          Justification = "Design decision.")]
      [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
      [SuppressMessage(
      "Gendarme.Rules.Maintainability", "AvoidLackOfCohesionOfMethodsRule",
      Justification = "What's there not to get?")]
      public class CollectOptions : ICollectOptions
      {
        private IEnumerable<string> commandLine;

        private CollectOptions()
        {
        }

        /// <summary>
        /// <para type="description">The folder containing the instrumented code to monitor (including the `AltCover.Recorder.g.dll` generated by previous a use of the .net core `AltCover`).</para>
        /// </summary>
        public string RecorderDirectory { get; set; }

        /// <summary>
        /// <para type="description">The working directory for the application launch</para>
        /// </summary>
        public string WorkingDirectory { get; set; }

        /// <summary>
        /// <para type="description">The executable to run e.g. `dotnet`</para>
        /// </summary>
        public string Executable { get; set; }

        /// <summary>
        /// <para type="description">File path for lcov format version of the collected data</para>
        /// </summary>
        public string LcovReport { get; set; }

        /// <summary>
        /// <para type="description">One or more of minimum acceptable statement (S), branch (B) or method (M) coverage percentage (integer, 1 to 100) or maximum acceptable CRAP score (C followed by integer, 1 to 255) e.g. M80C40B50. If the value starts with a number, a leading S is assumed. If any threshold is specified more than once, the last instance is assumed -- so 25S50 counts as S50. Zero/absent values are ignored. If a coverage result is below threshold, or the CRAP score is above threshold, the return code of the process is the largest abs(threshold - actual) rounded up to the nearest integer.</para>
        /// </summary>
        public string Threshold { get; set; }

        /// <summary>
        /// <para type="description">File path for Cobertura format version of the collected data</para>
        /// </summary>
        public string Cobertura { get; set; }

        /// <summary>
        /// <para type="description">Write the recorded coverage to this file rather than overwriting the original report file.</para>
        /// </summary>
        public string OutputFile { get; set; }

        /// <summary>
        /// <para type="description">Selects summary format (OpenCover style, or a TeamCity style, or both)</para>
        /// </summary>
        public string SummaryFormat { get; set; }

        /// <summary>
        /// <para type="description">Arguments for a launched process</para>
        /// </summary>
        public IEnumerable<string> CommandLine
        {
          get
          {
            return commandLine.ToArray();
          }
          set
          {
            commandLine = (value ?? Enumerable.Empty<string>()).ToArray();
          }
        }

        /// <summary>
        /// <para type="description">Gets whether to report any non-zero return code from a launched process.</para>
        /// </summary>
        public bool ExposeReturnCode { get; set; }

        /// <summary>
        /// Returns the F#-defined equivalent type
        /// </summary>
        /// <returns>An immutable representation of the same structure</returns>
        public OptionApi.CollectOptions ToOptions()
        {
          var primitive = new AltCover.Primitive.CollectOptions(
              RecorderDirectory,
              WorkingDirectory,
              Executable,
              LcovReport,
              Threshold,
              Cobertura,
              OutputFile,
              CommandLine,
              ExposeReturnCode,
              SummaryFormat
                                                              );
          return OptionApi.CollectOptions.NewPrimitive(primitive);
        }

        /// <summary>
        /// Create a default instance with all members empty, except `ExposeReturnCode = true`
        /// </summary>
        /// <returns>A new instance of the type</returns>
        public static CollectOptions Create()
        {
          return new CollectOptions
          {
            RecorderDirectory = string.Empty,
            WorkingDirectory = string.Empty,
            Executable = string.Empty,
            LcovReport = string.Empty,
            Threshold = string.Empty,
            Cobertura = string.Empty,
            OutputFile = string.Empty,
            CommandLine = Enumerable.Empty<string>(),
            ExposeReturnCode = true,
            SummaryFormat = string.Empty
          };
        }

        /// <summary>
        /// Check whether the parameters are sensible
        /// </summary>
        /// <param name="afterPreparation">Whether the prepare phase has been run and a `AltCover.Recorder.g.dll` should exist.</param>
        /// <returns>Any errors that would be reported to the command line</returns>
        public IEnumerable<string> Validate(bool afterPreparation)
        {
          return ToOptions().Validate(afterPreparation);
        }

        /// <summary>
        /// Performs validation (implies `Validate`) suitable for a PowerShell `-WhatIf` query; the return type has form
        /// <code>
        ///  public sealed class ValidatedCommandLine
        ///  {
        ///    public IEnumerable&lt;string&gt; Command { get; } // Command line elements
        ///    public IEnumerable&lt;string&gt; Errors { get; } // Validation errors
        ///    public override string ToString(); // nicely formatted
        ///  }
        /// </code>
        /// </summary>
        /// <param name="afterPreparation">Whether the prepare phase has been run and a `AltCover.Recorder.g.dll` should exist.</param>
        /// <returns>The state of the command line</returns>
        public OptionApi.ValidatedCommandLine WhatIf(bool afterPreparation)
        {
          return ToOptions().WhatIf(afterPreparation);
        }
      }

      /// <summary>
      ///  This type defines the Prepare (instrumentation) behaviour.    The properties map on to the command line arguments for `altcover`
      /// </summary>
      [SuppressMessage(
          "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
          Justification = "Design decision.")]
      [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
      [SuppressMessage(
      "Gendarme.Rules.Maintainability", "AvoidLackOfCohesionOfMethodsRule",
      Justification = "What's there not to get?")]
      public class PrepareOptions : IPrepareOptions
      {
        private IEnumerable<string> commandLine;

        private PrepareOptions()
        {
        }

        /// <summary>
        /// <para type="description">Folder or folders containing assemblies to instrument (default: current directory)</para>
        /// </summary>
        public IEnumerable<string> InputDirectories { get; set; }

        /// <summary>
        /// <para type="description">Folder or folders to receive the instrumented assemblies and their companions (default: sub-folder `__Instrumented` of the current directory; or `__Saved` if `-Inplace` is set).</para>
        /// </summary>
        public IEnumerable<string> OutputDirectories { get; set; }

        /// <summary>
        /// <para type="description">Additional folder or folders to search for matching symbols for the assemblies in the input directory</para>
        /// </summary>
        public IEnumerable<string> SymbolDirectories { get; set; }

        /// <summary>
        /// <para type="description">Assembly paths to resolve missing references.</para>
        /// </summary>
        public IEnumerable<string> Dependencies { get; set; }

        /// <summary>
        /// <para type="description">Strong name key or keys that were used to sign the inputs</para>
        /// </summary>
        public IEnumerable<string> Keys { get; set; }

        /// <summary>
        /// <para type="description">The default strong naming key to apply to instrumented assemblies</para>
        /// </summary>
        public string StrongNameKey { get; set; }

        /// <summary>
        /// <para type="description">The output report template file (default: coverage.xml in the current directory)</para>
        /// </summary>
        public string XmlReport { get; set; }

        /// <summary>
        /// <para type="description">Source file names to exclude from instrumentation</para>
        /// </summary>
        public IEnumerable<string> FileFilter { get; set; }

        /// <summary>
        /// <para type="description">Assembly names to exclude from instrumentation (linked by instrumented assemblies)</para>
        /// </summary>
        public IEnumerable<string> AssemblyFilter { get; set; }

        /// <summary>
        /// <para type="description">Assembly names to exclude from instrumentation (linked to instrumented assemblies)</para>
        /// </summary>
        public IEnumerable<string> AssemblyExcludeFilter { get; set; }

        /// <summary>
        /// <para type="description">Type names to exclude from instrumentation</para>
        /// </summary>
        public IEnumerable<string> TypeFilter { get; set; }

        /// <summary>
        /// <para type="description">Method names to exclude from instrumentation</para>
        /// </summary>
        public IEnumerable<string> MethodFilter { get; set; }

        /// <summary>
        /// <para type="description">Attribute names to exclude from instrumentation</para>
        /// </summary>
        public IEnumerable<string> AttributeFilter { get; set; }

        /// <summary>
        /// <para type="description">Source file paths to exclude from instrumentation</para>
        /// </summary>
        public IEnumerable<string> PathFilter { get; set; }

        /// <summary>
        /// <para type="description">Tracking either times of visits in ticks or designated method calls leading to the visits.</para>
        /// <para type="description">A single digit 0-7 gives the number of decimal places of seconds to report; everything else is at the mercy of the system clock information available through DateTime.UtcNow</para>
        /// <para type="description">A string in brackets "[]" is interpreted as an attribute type name (the trailing "Attribute" is optional), so [Test] or [TestAttribute] will match; if the name contains one or more ".", then it will be matched against the full name of the attribute type.</para>
        /// <para type="description">Other strings are interpreted as method names (fully qualified if the string contains any "." characters).</para>
        /// <para type="description">Incompatible with `SingleVisit` being true</para>
        /// </summary>
        public IEnumerable<string> CallContext { get; set; }

        /// <summary>
        /// <para type="description">Generate the report in the specified format (NCover or the default OpenCover)</para>
        /// </summary>
        public string ReportFormat { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to instrument the inputDirectory, rather than the outputDirectory (e.g. for `dotnet test`)</para>
        /// </summary>
        public bool InPlace { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to write raw coverage data to file for later processing</para>
        /// </summary>
        public bool Save { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to emit the XML report inside a zip archive.</para>
        /// </summary>
        public bool ZipFile { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to record only whether a method has been visited or not.  Overrides the `LineCover` and `BranchCover` options.</para>
        /// </summary>
        public bool MethodPoint { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to record only the first hit at any location.  Incompatible with `-CallContext`.</para>
        /// </summary>
        public bool SingleVisit { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to omit branch coverage.  Implies, and is compatible with, the -ReportFormat "opencover" option. Incompatible with `-BranchCover`.</para>
        /// </summary>
        public bool LineCover { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to omit ine coverage.  Implies, and is compatible with, the -ReportFormat "opencover" option. Incompatible with `-LineCover`.</para>
        /// </summary>
        public bool BranchCover { get; set; }

        /// <summary>
        /// <para type="description">Gets whether to report any non-zero return code from a launched process.</para>
        /// </summary>
        public bool ExposeReturnCode { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to display sourcelink URLs rather than file paths if present.</para>
        /// </summary>
        public bool SourceLink { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to defer writing runner-mode coverage data until process exit.</para>
        /// </summary>
        public bool Defer { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to exclude for instrumentation code for which the source file is not present.</para>
        /// </summary>
        public bool LocalSource { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to hide complex internal IL branching implementation details in switch/match constructs, and just show what the source level logic implies.</para>
        /// </summary>
        public bool VisibleBranches { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to instrument and show code that is by default skipped as trivial.</para>
        /// </summary>
        public string ShowStatic { get; set; }

        /// <summary>
        /// <para type="description">Indicate whether to mark generated code with a visit count of -2 (Automatic) for the Visualizer if unvisited</para>
        /// </summary>
        public bool ShowGenerated { get; set; }

        /// <summary>
        /// <para type="description">Arguments for a launched process</para>
        /// </summary>
        public IEnumerable<string> CommandLine
        {
          get
          {
            return commandLine.ToArray();
          }
          set
          {
            commandLine = (value ?? Enumerable.Empty<string>()).ToArray();
          }
        }

        /// <summary>
        /// Returns the F#-defined equivalent type
        /// </summary>
        /// <returns>An immutable representation of the same structure</returns>
        public OptionApi.PrepareOptions ToOptions()
        {
          var primitive = new AltCover.Primitive.PrepareOptions(
                          InputDirectories,
                          OutputDirectories,
                          SymbolDirectories,
                          Dependencies,
                          Keys,
                          StrongNameKey,
                          XmlReport,
                          FileFilter,
                          AssemblyFilter,
                          AssemblyExcludeFilter,
                          TypeFilter,
                          MethodFilter,
                          AttributeFilter,
                          PathFilter,
                          CallContext,

                          ReportFormat,
                          InPlace,
                          Save,
                          ZipFile,
                          MethodPoint,
                          SingleVisit,
                          LineCover,
                          BranchCover,
                          CommandLine,
                          ExposeReturnCode,
                          SourceLink,
                          Defer,
                          LocalSource,
                          VisibleBranches,
                          ShowStatic,
                          ShowGenerated
                                                              );
          return OptionApi.PrepareOptions.NewPrimitive(primitive);
        }

        /// <summary>
        /// Create a default instance with all members empty, except `ExposeReturnCode, InPlace, Save = true`
        /// </summary>
        /// <returns>A new instance of the type</returns>
        public static PrepareOptions Create()
        {
          return new PrepareOptions
          {
            InputDirectories = new string[0],
            OutputDirectories = new string[0],
            SymbolDirectories = new string[0],
            Dependencies = new string[0],
            Keys = new string[0],
            StrongNameKey = string.Empty,
            XmlReport = string.Empty,
            FileFilter = new string[0],
            AssemblyFilter = new string[0],
            AssemblyExcludeFilter = new string[0],
            TypeFilter = new string[0],
            MethodFilter = new string[0],
            AttributeFilter = new string[0],
            PathFilter = new string[0],
            CallContext = new string[0],

            ReportFormat = "OpenCover",
            InPlace = true,
            Save = true,
            SingleVisit = false,
            LineCover = false,
            BranchCover = false,
            CommandLine = { },

            ExposeReturnCode = true,
            SourceLink = false,
            Defer = false
          };
        }

        /// <summary>
        /// Check whether the parameters are sensible
        /// </summary>
        /// <returns>Any errors that would be reported to the command line</returns>
        public IEnumerable<string> Validate()
        {
          return ToOptions().Validate();
        }

        /// <summary>
        /// Performs validation (implies `Validate`) suitable for a PowerShell `-WhatIf` query; the return type has form
        /// <code>
        ///  public sealed class ValidatedCommandLine
        ///  {
        ///    public IEnumerable&lt;string&gt; Command { get; } // Command line elements
        ///    public IEnumerable&lt;string&gt; Errors { get; } // Validation errors
        ///    public override string ToString(); // nicely formatted
        ///  }
        /// </code>
        /// </summary>
        /// <returns>The state of the command line</returns>
        public OptionApi.ValidatedCommandLine WhatIf()
        {
          return ToOptions().WhatIf();
        }
      }

      /// <summary>
      /// Defines how to log output from the `altcover` operation
      /// </summary>
      [SuppressMessage(
          "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
          Justification = "Design decision.")]
      [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
      public class LoggingOptions : ILoggingOptions
      {
        private LoggingOptions()
        {
        }

        /// <summary>
        /// Sink for informational messages
        /// </summary>
        public Action<String> Info { get; set; }

        /// <summary>
        /// Sink for warning messages
        /// </summary>
        public Action<String> Warn { get; set; }

        /// <summary>
        ///  Sink for error messages
        /// </summary>
        public Action<String> StandardError { get; set; }

        /// <summary>
        /// Sink for the synthetic command line in case of inconsistent inputs.
        /// </summary>
        public Action<String> Echo { get; set; }

        /// <summary>
        /// Returns the F#-defined equivalent type
        /// </summary>
        /// <returns>An immutable representation of the same structure</returns>
        public OptionApi.LoggingOptions ToOptions()
        {
          var primitive = new AltCover.Primitive.LoggingOptions(
              OptionApi.LoggingOptions.ActionAdapter(Info),
              OptionApi.LoggingOptions.ActionAdapter(Warn),
              OptionApi.LoggingOptions.ActionAdapter(StandardError),
              OptionApi.LoggingOptions.ActionAdapter(Echo));
          return OptionApi.LoggingOptions.NewPrimitive(primitive);
        }

        /// <summary>
        /// Create a default instance with all members discarding all input
        /// </summary>
        /// <returns>A new instance of the type</returns>
        public static LoggingOptions Create()
        {
          return new LoggingOptions
          {
            Info = x => { },
            Warn = x => { },
            StandardError = x => { },
            Echo = x => { }
          };
        }
      }

      /// <summary>
      ///  Represents  other `altcover`-related command line arguments for the `dotnet test` operation
      /// </summary>
      [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly",
        Justification = "CLI is a standard TLA")]
      [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
      [SuppressMessage(
          "Gendarme.Rules.Design", "AvoidVisibleNestedTypesRule",
          Justification = "Design decision.")]
      [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible",
        Justification = "Design decision.")]
      public class CLIOptions : ICLIOptions
      {
        /// <summary>
        /// Indicates whether a left-over `__Saved` directory from a previous run should be forcibly deleted
        /// </summary>
        public bool Force { get; set; }

        /// <summary>
        /// Indicates whether to exit if the tests fail, without processing coverage data
        /// </summary>
        public bool FailFast { get; set; }

        /// <summary>
        /// Indicates the colour to use to display the coverage summary to stdout; a non-colour will use system default, empty will echo nothing
        /// </summary>
        public string ShowSummary { get; set; }
      }
    }

    /// <summary>
    /// Performs the instrumentation phase of `altcover`
    /// </summary>
    /// <param name="prepareArgs"></param>
    /// <param name="log"></param>
    /// <returns></returns>
    public static int Prepare(IPrepareOptions prepareArgs, ILoggingOptions log)
    {
      if (prepareArgs == null) throw new ArgumentNullException(nameof(prepareArgs));
      if (log == null) throw new ArgumentNullException(nameof(log));
      return Api.Prepare(prepareArgs.ToOptions(), log.ToOptions());
    }

    /// <summary>
    /// Performs the collection/reporting phase of `altcover`
    /// </summary>
    /// <param name="collectArgs">Description of the operation to perform</param>
    /// <param name="log">Where to route logging output</param>
    /// <returns>The return code of the operation</returns>
    public static int Collect(ICollectOptions collectArgs, ILoggingOptions log)
    {
      if (collectArgs == null) throw new ArgumentNullException(nameof(collectArgs));
      if (log == null) throw new ArgumentNullException(nameof(log));
      return Api.Collect(collectArgs.ToOptions(), log.ToOptions());
    }

    /// <summary>
    /// Get the PowerShell command needed to import `altcover` as a PowerShell module
    /// </summary>
    /// <returns>The PowerShell command</returns>
    public static string ImportModule()
    {
      return Api.ImportModule();
    }

    /// <summary>
    /// Get the version of `altcover` being used
    /// </summary>
    /// <returns>The version object</returns>
    public static Version Version()
    {
      return Api.Version();
    }

    private static DotNet.CLIOptions ToCLIOptions(ICLIOptions args)
    {
      var force = DotNet.CLIOptions.NewForce(args.Force);
      var failfast = DotNet.CLIOptions.NewFailFast(args.FailFast);
      var showsummary = DotNet.CLIOptions.NewShowSummary(args.ShowSummary);
      return DotNet.CLIOptions.NewMany(new[] { force, failfast, showsummary });
    }

    /// <summary>
    /// Converts the input into the command line for `dotnet test`
    /// </summary>
    /// <param name="prepareArgs">Description of the instrumentation operation to perform</param>
    /// <param name="collectArgs">Description of the collection operation to perform</param>
    /// <param name="control">All other `altcover` related command line arguments</param>
    /// <returns>The composed command line</returns>
    public static string ToTestArguments(IPrepareOptions prepareArgs,
                                         ICollectOptions collectArgs,
                                         ICLIOptions control)
    {
      if (prepareArgs == null) throw new ArgumentNullException(nameof(prepareArgs));
      if (collectArgs == null) throw new ArgumentNullException(nameof(collectArgs));
      return DotNet.ToTestArguments(prepareArgs.ToOptions(),
                                    collectArgs.ToOptions(),
                                    ToCLIOptions(control));
    }

    /// <summary>
    /// Converts the input into the command line for `dotnet test`
    /// </summary>
    /// <param name="prepareArgs">Description of the instrumentation operation to perform</param>
    /// <param name="collectArgs">Description of the collection operation to perform</param>
    /// <param name="control">All other `altcover` related command line arguments</param>
    /// <returns>The command line as a sequence of individual items</returns>
    public static IEnumerable<string> ToTestArgumentList(IPrepareOptions prepareArgs,
                                              ICollectOptions collectArgs,
                                              ICLIOptions control)
    {
      if (prepareArgs == null) throw new ArgumentNullException(nameof(prepareArgs));
      if (collectArgs == null) throw new ArgumentNullException(nameof(collectArgs));
      return DotNet.ToTestArgumentList(prepareArgs.ToOptions(),
                                       collectArgs.ToOptions(),
                                       ToCLIOptions(control)).
      ToArray();
    }
  }
}