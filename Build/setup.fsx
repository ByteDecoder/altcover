#r "paket:
nuget Fake.Core.Environment prerelease
nuget Fake.Core.Globbing prerelease
nuget Fake.Core.Process prerelease
nuget Fake.DotNet.Cli prerelease
nuget Fake.DotNet.NuGet prerelease //"

open System
open System.Collections.Generic
open System.IO
open System.Xml
open System.Xml.Linq

open Fake.Core.Environment
open Fake.Core.Globbing.Tools
open Fake.Core.Process
open Fake.DotNet.Cli
open Fake.DotNet.NuGet.Restore

open Microsoft.Win32


// Really bootstrap 
let dotnetPath = "dotnet" |> tryFindFileOnPath
let dotnetOptions o = match dotnetPath with
                      | Some f -> {o with DotNetCliPath = f}
                      | None -> o

DotNetRestore (fun o -> { o with
                            Packages = ["./packages"]
                            Common = dotnetOptions o.Common}) "./Build/dotnet-nuget.csproj"

// Restore the NuGet packages used by the build and the Framework version
let nuget = findNuget "." 
RestoreMSSolutionPackages id "./AltCover.sln"

// Get the paths to the current NuGet versions used by the build and feed into the primary build script
let lookup = Dictionary<string, string>()
let xml = XDocument.Load "./MCS/packages.config"
xml.Descendants(XName.Get("package"))
|> Seq.iter(fun package -> lookup.Add (package.Attribute(XName.Get("id")).Value, 
                                       package.Attribute(XName.Get("version")).Value))

let here = Path.Combine(Directory.GetCurrentDirectory(), "packages")

let fake = "FAKE." + lookup.["FAKE"]
Directory.GetDirectories(here, "FAKE.*") 
|> Seq.filter (fun n -> Path.GetFileName n <> fake)
|> Seq.iter(fun n-> Directory.Delete(n, true))

let packages = [
  ("FAKE", None, "FakeLib.dll")
  ("FSharpLint.Fake", None, "FSharpLint.Fake.dll")
  ("FSharp.Formatting", None, "FSharp.Markdown.dll")
  ("NUnit", Some "net45", "nunit.framework.dll")
  ("YamlDotNet", Some "net45", "YamlDotNet.dll")
               ] |> List.map (fun (p,o,f) -> let root = Path.Combine(here, p + "." + lookup.[p])
                                             (Directory.GetFiles(root, f, SearchOption.AllDirectories)
                                             |> Seq.filter (fun n -> match o with
                                                                     | None -> true
                                                                     | Some x -> n.Contains x)
                                             |> Seq.map Path.GetDirectoryName
                                             |> Seq.head, f))

let build = """// generated by dotnet fake run .\Build\setup.fsx
#I @"{0}" // include Fake lib
#r "{1}"
#I @"{2}"
#r "{3}"
#I @"{4}"
#r "{5}"
#I @"{6}"
#r "{7}"
#I @"{8}"
#r "{9}"

#r "System.IO.Compression.FileSystem.dll"
#r "System.Xml"
#r "System.Xml.Linq"

#load "actions.fsx"
#load "targets.fsx"
"""

let formatted = String.Format(build, 
                              fst packages.[0], 
                              snd packages.[0], 
                              fst packages.[1], 
                              snd packages.[1], 
                              fst packages.[2],
                              snd packages.[2], 
                              fst packages.[3],
                              snd packages.[3], 
                              fst packages.[4],
                              snd packages.[4])
File.WriteAllText("./Build/build.fsx", formatted)

let fakepath =  findToolInSubPath "FAKE.exe" "."

if isWindows then
  use hklmKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32)
  use key = hklmKey.OpenSubKey(@"SOFTWARE\Microsoft\VisualStudio\SxS\VS7")
  let vsInstallPath = key.GetValue("15.0") :?> string
  let vcTools = Path.Combine(vsInstallPath, @"Common7\Tools")
  let batchFile = Path.Combine(vcTools, "VsDevCmd.bat")
  let fakebat = """@echo off
REM generated by dotnet fake run .\Build\setup.fsx  
IF '"%VS150COMNTOOLS%"' == '""' CALL "{0}"
"{1}" ".\Build\build.fsx" "%1"
exit /b %errorlevel%
"""
  let f1 = String.Format(fakebat, batchFile, fakepath)
  File.WriteAllText("./fake.bat", f1)
else
  let fakesh = """#!/bin/sh
# generated by dotnet fake run .\Build\setup.fsx
mono {0} Build/build.fsx
"""
  let f2 = String.Format(fakesh, fakepath)
  File.WriteAllText("./fake.sh", f2)