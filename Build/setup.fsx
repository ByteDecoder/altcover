#r "paket:
nuget Fake.Core.Environment prerelease
nuget Fake.Core.Globbing prerelease
nuget Fake.Core.Process prerelease
nuget Fake.DotNet.Cli prerelease
nuget Fake.DotNet.NuGet prerelease //"
open System
open System.IO

open Fake.Core.Environment
open Fake.Core.Globbing.Tools
open Fake.Core.Process
open Fake.DotNet.Cli
open Fake.DotNet.NuGet.Restore

open Microsoft.Win32


// Really bootstrap 
let dotnetPath = "dotnet" |> tryFindFileOnPath
let dotnetOptions = match dotnetPath with
                    | Some f -> {DotnetOptions.Default with DotnetCliPath = f}
                    | None -> DotnetOptions.Default

DotnetRestore (fun o -> { o with 
                            Packages = ["./packages"]
                            Common = dotnetOptions}) "./Build/dotnet-nuget.csproj"

// Restore the NuGet packages used by the build and the Framework version
let nuget = findNuget "." 
RestoreMSSolutionPackages id "./AltCover.sln"

// Get the paths to the current NuGet versions used by the build and feed into the primary build script
let here = Directory.GetCurrentDirectory()
let fakelib = Directory.GetFiles(here, "*akeLib.dll", SearchOption.AllDirectories)
              |> Seq.head
              |> Path.GetDirectoryName

let lintlib = Directory.GetFiles(here, "*SharpLint.Fake.dll", SearchOption.AllDirectories)
              |> Seq.head
              |> Path.GetDirectoryName

let mdlib = Directory.GetFiles(here, "*Sharp.Markdown.dll", SearchOption.AllDirectories)
            |> Seq.filter (fun n -> n.Contains("net40"))
            |> Seq.head
            |> Path.GetDirectoryName

let ylib = Directory.GetFiles(here, "*amlDotNet.dll", SearchOption.AllDirectories)
            |> Seq.filter (fun n -> n.Contains("net35"))
            |> Seq.head
            |> Path.GetDirectoryName

let nlib = Directory.GetFiles(here, "*framework.dll", SearchOption.AllDirectories)
            |> Seq.filter (fun n -> n.Contains("net45"))
            |> Seq.head
            |> Path.GetDirectoryName

let build = """// generated by dotnet fake run .\Build\setup.fsx
#I @"{0}" // include Fake lib
#r "FakeLib.dll"
#I @"{1}"
#r "FSharpLint.Fake.dll"
#I @"{2}"
#r "FSharp.Markdown.dll"
#I @"{3}"
#r "YamlDotNet.dll"
#I @"{4}"
#r "nunit.framework.dll"
#r "System.IO.Compression.FileSystem.dll"
#r "System.Xml"
#r "System.Xml.Linq"

#load "actions.fsx"
#load "targets.fsx"
"""

let formatted = String.Format(build, fakelib, lintlib, mdlib, ylib, nlib)
File.WriteAllText("./Build/build.fsx", formatted)

let fakepath =  findToolInSubPath "FAKE.exe" "."

if isWindows then
  use hklmKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32)
  use key = hklmKey.OpenSubKey(@"SOFTWARE\Microsoft\VisualStudio\SxS\VS7")
  let vsInstallPath = key.GetValue("15.0") :?> string
  let vcTools = Path.Combine(vsInstallPath, @"Common7\Tools")
  let batchFile = Path.Combine(vcTools, "VsDevCmd.bat")
  let fakebat = """@echo off
REM generated by dotnet fake run .\Build\setup.fsx  
IF '"%VS150COMNTOOLS%"' == '""' CALL "{0}"
"{1}" ".\Build\build.fsx" "%1"
exit /b %errorlevel%
"""
  let f1 = String.Format(fakebat, batchFile, fakepath)
  File.WriteAllText("./fake.bat", f1)
else
  let fakesh = """#!/bin/sh
# generated by dotnet fake run .\Build\setup.fsx
mono {0} Build/build.fsx
"""
  let f2 = String.Format(fakesh, fakepath)
  File.WriteAllText("./fake.sh", f2)