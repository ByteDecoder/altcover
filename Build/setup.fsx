#r "paket:
nuget Fake.Core.Environment prerelease
nuget Fake.Core.Globbing prerelease
nuget Fake.Core.Process prerelease
nuget Fake.DotNet.Cli prerelease
nuget Fake.DotNet.NuGet prerelease //"
open System
open System.IO

open Fake.Core.Environment
open Fake.Core.Globbing.Tools
open Fake.Core.Process
open Fake.DotNet.Cli
open Fake.DotNet.NuGet.Restore

open Microsoft.Win32


// Really bootstrap 
let dotnetPath = "dotnet" |> tryFindFileOnPath
let dotnetOptions = match dotnetPath with
                    | Some f -> {DotnetOptions.Default with DotnetCliPath = f}
                    | None -> DotnetOptions.Default

DotnetRestore (fun o -> { o with 
                            Packages = ["./packages"]
                            Common = dotnetOptions}) "./Build/dotnet-nuget.csproj"

// Restore the NuGet packages used by the build and the Framework version
let nuget = findNuget "." 
RestoreMSSolutionPackages id "./AltCover.sln"

// Get the paths to the current NuGet versions used by the build and feed into the primary build script
let cache = Path.Combine (Environment.GetFolderPath Environment.SpecialFolder.UserProfile,
                          ".nuget/packages")
let lint =  Path.Combine  (cache, "fsharplint.fake")                     
let lintlib = Directory.GetFiles(lint, "*SharpLint.Fake.dll", SearchOption.AllDirectories)
              |> Seq.last
              |> Path.GetDirectoryName

let md = Path.Combine  (cache, "fsharp.formatting") 
let mdlib = Directory.GetFiles(md, "*Sharp.Markdown.dll", SearchOption.AllDirectories)
            |> Seq.filter (fun n -> n.Contains("net40"))
            |> Seq.last
            |> Path.GetDirectoryName

let build = """// generated by dotnet fake run .\Build\setup.fsx
#r "paket:
nuget Fake.Core.Target prerelease
nuget Fake.Core.Environment prerelease
nuget Fake.Core.Globbing prerelease
nuget Fake.Core.Process prerelease
nuget Fake.DotNet.AssemblyInfoFile prerelease
nuget Fake.DotNet.Cli prerelease
nuget Fake.DotNet.MsBuild prerelease
nuget Fake.DotNet.NuGet prerelease
nuget Fake.DotNet.Testing.NUnit prerelease
nuget Fake.DotNet.Testing.OpenCover prerelease
nuget Fake.IO.FileSystem prerelease
nuget coveralls.io >= 1.4.2
nuget FSharp.Formatting >= 2.14.4
nuget FSharpLint.Fake >= 0.9.0
nuget NUnit >= 3.9.0
nuget YamlDotNet >= 4.3.0 //"
#I @"{0}"
#r "FSharpLint.Fake.dll"
#I @"{1}"
#r "FSharp.Markdown.dll"
#r "System.IO.Compression.FileSystem.dll"
#r "System.Xml"
#r "System.Xml.Linq"

#load "actions.fsx"
#load "targets.fsx"
"""

let formatted = String.Format(build, lintlib, mdlib)
File.WriteAllText("./Build/build.fsx", formatted)

let fakepath =  findToolInSubPath "FAKE.exe" "."

if isWindows then
  use hklmKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32)
  use key = hklmKey.OpenSubKey(@"SOFTWARE\Microsoft\VisualStudio\SxS\VS7")
  let vsInstallPath = key.GetValue("15.0") :?> string
  let vcTools = Path.Combine(vsInstallPath, @"Common7\Tools")
  let batchFile = Path.Combine(vcTools, "VsDevCmd.bat")
  let fakebat = """@echo off
REM generated by dotnet fake run .\Build\setup.fsx  
IF '"%VS150COMNTOOLS%"' == '""' CALL "{0}"
"{1}" ".\Build\build.fsx" "%1"
exit /b %errorlevel%
"""
  let f1 = String.Format(fakebat, batchFile, fakepath)
  File.WriteAllText("./fake.bat", f1)
else
  let fakesh = """#!/bin/sh
# generated by dotnet fake run .\Build\setup.fsx
mono {0} Build/build.fsx
"""
  let f2 = String.Format(fakesh, fakepath)
  File.WriteAllText("./fake.sh", f2)